# Database

The database is designed using a code-first approach, which simply means that the database and its relations have been
defined using Python classes. This is done with the help of `SQLAlchemy` a Python object relational mapping (ORM). The
alternative to using ORM is writing SQL-code and running the scripts through Python. This can be time-consuming and lead
to bugs inconsistencies in local databases.

Another tool that is used to manage the database is `alembic` - a database migration tool. This allows us to keep track
of which changes have been created in the database and roll back to previous version. When a change has been applied to
the database schema, a migration can be created and works as a checkpoint. One can think about it like Git for
databases. This is especially useful when working with multiple developers and environments. By running simple commands
we can ensure that everyone and everything is up to date with the latest database schema.

## SQLAlchemy

> [!TIP]
> [SQLAlchemy Documentation](https://docs.sqlalchemy.org/en/20/)

The ORM translates Python objects to SQL-code that defines our database schema. Let's say we have two tables `Author`
and `Quote` and want to create a one-to-many relationship between `Author` and `Quote`. Meaning one author can have
multiple quotes, but one quote can only have one author. This relationship can be captured with the following code:

```python
# author.py
from sqlalchemy import Column, Integer, String
from sqlalchemy.orm import relationship

from ..base import Base


class Author(Base):
    __tablename__ = "authors"

    id: int = Column(Integer, primary_key=True, autoincrement=True, nullable=False)
    name: str = Column(String(300), nullable=False)
    about_url: str = Column(String(400), nullable=False)

    quotes = relationship("Author", back_populates="quotes", cascade="all, delete-orphan")

    def __init__(self, name: str, about_url: str, quotes: list = None):
        super().__init__()

        if quotes is None:
            quotes = []

        self.name = name
        self.about_url = about_url
        self.quotes = quotes


# quote.py
from sqlalchemy import Column, Integer, Text, ForeignKey
from sqlalchemy.orm import relationship

from ..base import Base


class Quote(Base):
    __tablename__ = "quotes"

    id: int = Column(Integer, primary_key=True, autoincrement=True, nullable=False)
    quote: str = Column(Text, nullable=False)
    author_id: int = Column(Integer, ForeignKey("authors.id"), nullable=False)

    author = relationship("Quote", back_populates="author")

    def __init__(self, quote: str) -> None:
        super().__init__()
        self.quote = quote
```

There are a some things to note:

- Both classes extend `Base` which can be found in the sister-directory `base`. This is needed for `SQLAlchemy` to
  recognize the entity in the schema
- `__tablename__` is present in both entities. This is also a requirements, and failing to include this field will
  result in an error
- The constructors (`__init__(self, ...)`) do not contain `id` as an input even though `id` is a required input. `id`
  has been set to autoincrement meaning the ID will be autogenerated. This will often be the case, but not always. In
  those cases ensure to pass it as a parameter in the constructor.
- The fields `quotes` in `author.py` and `author` in `quote.py` do not have any type. That is due to a circular import.

Keep in mind that the database definition can be found in the `domain` package - the reason why can you read more about
in the section about [architecture](architecture.md).

## Alembic

> [!TIP]
> [Alembic documentation](https://alembic.sqlalchemy.org/en/latest/)

First of all, ensure that your virtual environment is activated. *Unsure how? Read more about it [here](../README.md).*
The following is a tutorial on how to create and apply migrations using the alembic CLI. Before that we will define some
terms:

**Database schema**
This is the structure and rules in the database. Examples of this can be

- Tables and their names
- Columns
- Primary- and foreign keys
- Constraints (like `NOT NULL`)

**Database state**

This refers to the actual content in the database - rows. So when developing with local databases we would have
different database states, but the schema have to be the same across all environments.

**Migration**

A set of version controlled changes to a *database schema*. It can represent a specific change like adding a new
column, creating a new relation or removing a table.

**Migration script**

An autogenerated script that represents the changes in the migration. This code will run when applying the migration.

**Applying a migration**

This basically means executing the migration scripts. The database schema will not be updated unless a migration have
been applied.

### Important commands

> [!IMPORTANT]
> Always check migration scripts manually before applying migration. These tools are good, but not perfect.

Create a migration script

```powershell
alembic revision --autogenerate -m "<message>"
```

where `<message>` should be a brief and descriptive title. The migration script will have this as the title.

Apply all unapplied migrations with

```powershell
alembic upgrade head
```

or `alembic upgrade 1` to only apply the first unapplied migration

and in the case where you would like to revert a migration

```powershell
ambelic downgrade -1
```

### Settings

Alembic know what the current database schema looks like by connecting to the database and looking at the version table.
This obviously means that the database container must be up and running. If you wish to apply migrations to `seoul-2`
RaspberryPi ensure that the database URI have been changed in [`config.py`](../src/config.py). The IP-address have to be
updated. **However, ensure that it is changed back to the local database when you are done.**